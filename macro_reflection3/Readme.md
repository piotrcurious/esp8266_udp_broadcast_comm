The advantage of this architecture is that it makes the code platform-independent by using fixed-size types and macros to define the data elements. This way, the sender and receiver can have different architectures and still communicate using the same data packet format. The macros also make it easy to add or remove data elements without changing the rest of the code. The serialization and deserialization functions use memcpy to copy the bytes of each data element to and from a byte array. This ensures that the data is not modified or corrupted during transmission. The byte array can then be sent or received as a UDP packet using the WiFiUDP library.
Yes, it will work for any type that can be copied by memcpy. However, you should be careful with floats because they may have different representations on different architectures. For example, some architectures may use single-precision floats (32 bits) while others may use double-precision floats (64 bits). This could cause data loss or corruption if the sender and receiver have different float sizes. A possible solution is to use a fixed-point representation instead of a float, or to use a standard format like IEEE 754 for floats.
